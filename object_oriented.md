# 面向对象的基本概念
这里所指的面向对象，准确地说应该叫做面向对象编程（OOP），是面向对象的一部分。面向对象包括三部分：
面向对象分析（OOA）、面向对象设计（OOD）、以及面向对象编程（OOP）。面向对象编程的两个重点概念是类
和对象。

## 类
世间万物都有其自身的属性方法，通过这些属性和方法可以将不同物质区分开来。
类是属性和方法的集合，是面向对象编程的核心和基础，

## 对象
类只是具备某项功能的抽象模型，实际应用中还需要对类进行实例化，这样就引入了对象的概念。对象是类进行
实例化后的产物，是一个实体。对象是类的一个实例化。一个具体存在的类的实例。

## 面向对象编程的三个特点
面向对象编程的三个特点是 封装性、继承性和多态性

1. 封装性

封装性，也可以称为信息隐藏，也就是将一个类的使用和实现分开，只保留有限的接口与外部联系。对于用到该
类的开发人员，只要知道这个类该如何使用即可，而不用关心这个类是如何实现的。这样做可以让开发人员更多
地把精力集中起来专注别的事情，同时也避免了程序之间地相互依赖而带来不便

2. 继承性

继承性就是派生类（子类）自动继承一个或多个（父类）中地属性与方法，并可以重写或添加新的属性和方法。
继承这个特性简化了对象和类的创建，增加了代码的可重用性。
**继承分单继承和多继承，php支持的是单继承，也就是说，一个子类有且只有一个父类**

3. 多态性

多态性是指同一个类的不同对象，使用同一方法可以获得不同的结果，这种技术称为多态性

# php 与对象
## 类的定义
和很多面向对象的语言一样，php也是通过class关键字加类名来定义类的。
类定义的格式如下：
```php
<?php
    class SportObject{
        ...
    }
?>
```

上述大括号中间的部分就是类的全部内容，如上述SportObject就是一个最简单的类。SportObject类仅有一个
类的骨架，什么功能也没有实现，但这不影响它的存在。

一个类，即一对大括号之间的全部内容都要在一段代码段中，即一个<?php ?> 之间不能分割成多块，有些自定
义的过程可以。

## 成员方法
类中的函数被称为成员方法。函数和成员方法唯一的区别就是，函数实现的是某个独立的功能，而成员方法是实
现类中的一个行为，是类的一部分。
一下实现有一个成员方法的类
```php
<?php
    class SportObject{
        function beatBasketball($name, $height, $avoirdupois, $age, $sex) {
            echo "姓名".$name;
            echo "身高".$height;
            echo "年龄".$age;
        }
    }
?>
```

该方法的作用是输出申请篮球人的基本信息。这些信息是通过方法的参数传进来的。

## 类的实例化
类的方法已经添加，接下来就是使用方法，但使用方法不像使用函数那么简单。首先要对类进行实例化，实例化是
通过关键字 new 声明一个对象。然后使用如下格式来调用要使用的方法：
对象名 -> 成员方法

类是一个抽象的描述，是功能相似的一组对象的集合。如果想用类中的方法或变量，首先就要把它具体落实到一个
实体，也就是对象上

实例化一个对象的代码如下：
```php
<?php
    class SportObject{
        function beatBasketball($name, $height, $avoidupois, $age, $sex){         // 声明成员方法 
            if ($height>180 and $avoidupois<=100) {
                return $name."，符合打篮球的要求！";
            } else {
                return $name."，不符合打篮球的要求！";                             // 方法实现的功能
            }
        }
    }
    $sport = new SportObject();
    echo $sport->beatBasketball('明日', "185", "80", "20 周岁", "男");
?>
```

## 成员变量
类中的变量，也称为成员变量。成员变量用来保存信息数据，或与成员方法进行交互来实现某项功能。
定义成员变量的格式为：
关键字 成员变量名
关键字可以使用public、private、protected、static和final中的任意一个。

访问成员变量和访问成员方法一样的。只要把成员方法换成成员变量即可，格式为：
对象名 -> 成员变量

[实例化一个对象，并调用对象的方法。](./chapter_14_ObjectOriented/SportObject.php)
`$this->` 的作用是调用本类中的成员变量或成员方法，这里只要知道含义即可。
无论使用`$this->` 还是使用 `对象名->` 的格式，后面的变量是没有 $ 符号的，如“$this->beatBasketBall” 等

## 类常量
既然有变量，当然也会有常量。常量就是不会改变的量，是一个恒值。圆周率是众所周知的一个常量。定义常量使用
关键字const
```php
<?php
    class SportObject{
        const BOOK_TYPE = '计算机图书';
        public $object_name;
        function setObjectName($name) {
            $this->object_name = $name;
        }
        
        function getObjectName(){
            return $this->object_name;
        }
    }
    $c_book = new SportObject();
    $c_book->setObjectName('PHP 类');
    echo SportObject::BOOK_TYPE."->";
    echo $c_book->getObjectName();
?>
``` 

运行以上代码，可以看出，常量的输出和变量的输出是不一样的。常量不需要实例化对象，直接有“类名::常量名”调用即可。

类名和常量名之间的两个冒号“::” 称为**作用域操作符**，使用这个操作符可以在不创建对象的情况下调用类中的常量、变量和方法。

## 构造方法 和 析构方法
### 1. 构造方法
当一个类实例化一个对象时，可能会随着对象初始化一些成员变量。

如果初始赋值较多，一项一项赋值就非常麻烦。为此 php 引入了构造方法。构造方法是生成对象时自动执行的成员方法，
作用就是初始化对象。该方法可以没有参数，也可以有多个参数。构造方法格式如下：
```void __construct([mixed args [,...]])```
函数中的下划线为双下划线

[采用构造函数初始化一个对象，并调用对象的方法。](./chapter_14_ObjectOriented/reSportObject.php)

### 2.析构方法
析构方法的作用和构造方法正好相反，是对象被销毁时被调用，作用是释放内存。析构方法的格式为：
```void __destruct(void)```
[采用析构函数查看销毁流程，当对象对销毁时调用__destruct()函数。](./chapter_14_ObjectOriented/destructObject.php)

## 继承和多态的实现
继承和多态最根本的作用就是完成代码的重用。
### 继承
子类继承父类的所有成员变量和方法，包括构造函数，当子类被创建时，php会现在子类中查找构造方法，如果
子类有自己的构造方法， php 会先调用子类中的方法。当子类中没有， php 则去调用父类中的构造方法，这就是继承。

继承是通过 extends 来声明的
[关于继承的一个实例，](./chapter_14_ObjectOriented/extends_inherit.php)

### 多态
多态好比有人叫大家去游泳，这个时候有的人带游泳圈，有的人带浮板，还有的人什么都没带。同样一种方法，
出现不同的形态，这就是多态

多态存在两种形式：
1. 覆盖

所谓覆盖就是在子类中重写父类的方法，而在两个子类的对象中虽然调用的是父类中相同的方法，但返回的结果是不同的。

2. 重载

重载是多态的另一种实现，函数重载指一个标识符被用作多个函数名，且能够通过函数的参数个数或参数类型将这些重名
的函数区分开来，调用不发生混淆。其好处是可实现代码重用

[关于重载的一个示例](./chapter_14_ObjectOriented/heavy_load.php)
```php
<?php
// example
    class C{
        function __call($name, $arguments) {
 // TODO: Implement __call() method.
 echo "方法名称：".$name."<p>";
 echo "参数存在个数：".count($arguments)."<p>";
 if (count($arguments) === 1) {
     echo $this->list1($arguments);
 } 
 if (count($arguments) === 2) {
    echo $this->list2($arguments[0], $arguments[1]);   
}
    }
    public function list1($a) {
            return "这是一个 list1 函数";
    }
    
    public function list2($a, $b) {
            return "这是一个 list1 函数";
    }
    }
    $a = new C;
    $a->listshow(1, 2);

?>
```
